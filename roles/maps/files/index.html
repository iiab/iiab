<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset='utf-8'>

        <link rel='stylesheet' href='maplibre-gl.css' />
        <script src='maplibre-gl.js'></script>

        <script src="maps.black-component.js" type="module"></script>
        <script>
            window.addEventListener("load", () => {
                const styleChooser = document.getElementById("styleswitch")
                let highDef = null // unset until we know whether we have the high def map
                function setStyle() {
                    mb.mapstyle = {
                        light: {
                            true:  "openstreetmap-openmaptiles/maputnik/liberty",
                            false: "naturalearth-openmaptiles/maputnik/liberty",
                        },
                        dark:  {
                            true:  "openstreetmap-openmaptiles/cartodb/dark-matter",
                            false: "naturalearth-openmaptiles/cartodb/dark-matter",
                        },
                        hybrid:  {
                            true:  "openstreetmap-openmaptiles/maps.black/hybrid-2023",
                            false: "naturalearth-openmaptiles/maps.black/hybrid-2023", // we'll have a smaller satellite file with the same name in this case
                        },
                        satellite:  {
                            true:  "raster/s2maps/2023",
                            false: "raster/s2maps/2023", // we'll have a smaller satellite file with the same name in this case
                        },
                    }[styleChooser.value][highDef]
                    console.log("setting to", mb.mapstyle)

                    addControls() // The above will reset the map so we have to add search again. This also covers page load.
                }

                // HEAD request just to see if the high def pmtiles file is there
                var http = new XMLHttpRequest();
                http.open('HEAD', "openstreetmap-openmaptiles.pmtiles");
                http.onreadystatechange = function() {
                    if (this.readyState == this.DONE) {
                        // If we get a 200 it means the high def pmtiles file
                        // exists.
                        highDef = this.status === 200

                        // Set the mapstyle as soon as we know whether it
                        // should be high def. This will probably be the
                        // initial state of the dropdown, since this will
                        // probably finish before the user has a chance to
                        // change the dropdown.
                        setStyle()
                    }
                };
                http.send();

                class MapsDotBlackGlobeControl extends maplibregl.GlobeControl {
                    onAdd(map) {
                        // Depends on GlobeControl using `_toggleProjection` internally in this
                        // way, which might change in a different version of maplibregl:
                        // https://github.com/maplibre/maplibre-gl-js/blob/93634b011a147666a62887bc61bffd351fa9971d/src/ui/control/globe_control.ts
                        //
                        // The reason we are doing this is that maps.black has its own wrapper for
                        // projection, among other aspects of the map. Rather than directly accessing the
                        // underlying map object to change the projection (as maplibregl.GlobeControl
                        // does), we will overload this method to use maps.black's wrapper.
                        //
                        // TODO implement this in a less hacky way, maybe. like maybe from scratch?
                        this._toggleProjection = () => {
                            // Not ideal to use the global `mb` but the alternative would be contrived and probably more error prone
                            mb.globe = !mb.globe

                            // Changing "features" of mb such as globe seems to rebuild the map, and in
                            // the process dumping all of the controls we added. So, we have to add them
                            // again.
                            addControls()
                        }

                        return super.onAdd(map)
                    }
                }

                const mb = document.getElementsByTagName("maps-black")[0];

                // set the mapstyle on dropdown change
                styleChooser.addEventListener('change', setStyle)

                // https://maplibre.org/maplibre-gl-js/docs/examples/geocode-with-nominatim/
                const nominatimGeocoderApi = {
                    // TODO reverse geocode
                    forwardGeocode: async (config) => {
                        const features = [];
                        try {
                            const request = `/nominatim/search?q=${
                                config.query
                            }&format=geojson&polygon_geojson=1&addressdetails=1&extratags=1`;
                            const response = await fetch(request);
                            const geojson = await response.json();
                            for (const feature of geojson.features) {
                                const center = [
                                    feature.bbox[0] + (feature.bbox[2] - feature.bbox[0]) / 2,
                                    feature.bbox[1] + (feature.bbox[3] - feature.bbox[1]) / 2,
                                ];
                                const point = {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Point',
                                        coordinates: center
                                    },
                                    place_name: feature.properties.display_name,
                                    properties: feature.properties,
                                    text: feature.properties.display_name,
                                    place_type: ['place'],
                                    extratags: feature.properties.extratags,
                                    center,

                                    // TODO When you click on a search result in the list, it sets the view around that *specific* result's *bbox* specified here.
                                    // On the other hand, hitting Enter in the search input sets the view around *all* of the result *markers* (with maximum zoom of 10).
                                    // Ideally, it would set the view around *all* of the result *bboxes*, I think. So let's figure that out.
                                    bbox: feature.bbox,
                                };
                                features.push(point);
                            }
                            // Just show borders for all results, for demo purposes for now.
                            // Cut off at 5 because that's the number of markers that get shown.
                            // TODO - have it only show the border when you actually click on a search result.
                            showSearchResultBorder(geojson.features.slice(0, 5))
                        } catch (e) {
                            console.error(`Failed to forwardGeocode with error: ${e}`);
                        }

                        return {
                            features
                        };
                    }
                };

                function showSearchResultBorder(searchResult) {
                    const source = mb.map.getSource('search-result')
                    if (source) {
                        // TODO - can we do source.updateData(searchResult) instead ???
                        mb.map.removeLayer('search-result-polygons')
                        mb.map.removeLayer('search-result-outline')
                        mb.map.removeSource('search-result')
                    }
                    mb.map.addSource('search-result', {
                      type: 'geojson',
                      data: {type: 'FeatureCollection', features: searchResult}
                    });
                    mb.map.addLayer({id: "search-result-polygons", type: "fill", source: 'search-result', layout:{}, paint: {'fill-color': '#FF4444', 'fill-opacity': 0.2}})
                    mb.map.addLayer({id: "search-result-outline", type: "line", source: 'search-result', layout:{}, paint: {'line-color': '#FF4444', 'line-width': 2}})
                }

                // have to use MAX_ZOOM in a couple different places to cover a couple different scenarios, it seems
                const MAX_ZOOM = 10;
                const geocoder = new MaplibreGeocoder(nominatimGeocoderApi, {
                    maplibregl,
                    zoom: MAX_ZOOM,
                    flyTo: {
                        maxZoom: MAX_ZOOM,
                    },
                    popup: true,
                })
                let addControlsTimeout = null
                function addControls() {
                    // Whether we're setting a new timeout or actually adding the search, make sure no further timeouts are looming.
                    clearTimeout(addControlsTimeout)
                    if (geocoder._map) {
                      // Neither add a map nor set a timer
                      return
                    }

                    // TODO use a maps-dot-black "on add map" callback instead, if such a thing exists.
                    // The problem is that at on creation, mb doesn't immediately contain a map.
                    if (mb.map && mb.map.style) { // NOTE mb.map.loaded() becomes true much later than mb.map.style. mb.map.style seems to be sufficient.
                        // sigh. deal with sneaking the style sheets into a "Shadow DOM" here. Thankfully this somehow isn't an issue with javascript.
                        // https://stackoverflow.com/questions/79736280/importing-a-css-stylesheet-into-a-webcomponent-with-shadow-dom-in-firefox/79744809#79744809
                        // TODO - See if I can do this in a more direct way. I only need the geocoder css as part of this shadow DOM. Also I probably don't need the
                        // other maplibre css, that's probably already included in maps.black.
                        const mapLibreGlCSS = [...document.styleSheets].find((styleSheet) => styleSheet.href.split('/').pop() === 'maplibre-gl-geocoder.css');
                        const stylesheetText = [...mapLibreGlCSS.cssRules].reduce((accumulator, rule) => accumulator + rule.cssText, '');
                        const myStyles = new CSSStyleSheet()
                        myStyles.replace(stylesheetText)
                        mb.shadowRoot.adoptedStyleSheets = [...mb.shadowRoot.adoptedStyleSheets, myStyles]

                        mb.map.addControl(geocoder, 'top-left');
                        mb.map.addControl(new maplibregl.ScaleControl());
                        mb.map.addControl(new MapsDotBlackGlobeControl(), 'top-right');
                        // NOTE Navigation control is added via `navigationcontrol` attribute on the maps-black tag
                    } else {
                        // For now try periodically until it's ready.
                        addControlsTimeout = setTimeout(addControls, 100)
                    }
                }
            });
        </script>
    </head>
    <body>
        <maps-black style="height:90vh" loader="pmtiles" navigationcontrol="true"></maps-black>
        <span class="styleSelection">
            <label class="styleswitchwrapper">Map style <select class="styleswitch" id="styleswitch">
                <option value="light">Light</option>
                <option value="dark">Dark</option>
                <option value="satellite">Satellite</option>
                <option value="hybrid">Hybrid map/satellite</option>
            </select></label>
        </span>
        <script src="maplibre-gl-geocoder.min.js"></script>
        <link
            rel="stylesheet"
            href="maplibre-gl-geocoder.css"
        />
    </body>
</html>
