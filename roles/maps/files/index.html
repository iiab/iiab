<!DOCTYPE html>
<html lang="en" style="height:100vh;">
    <head>
        <meta charset='utf-8'>

        <link rel='stylesheet' href='maplibre-gl.css' />
        <script src='maplibre-gl.js'></script>

        <script src="maps.black-component.js" type="module"></script>
        <script>
            // globally scoped function, for access from select tag's onchange handler.
            // TODO This code layout sucks, should clean it.
            let setStyle = null

            // we want style choice to survive the map reset that happens when a maps.black
            // feature or style changes, so we rely on this instead of the select tag value
            let mapStyleChoice = "natural"
            window.addEventListener("load", () => {
                let osmTiles = null // unset until we know whether we have the osm tiles
                function _setStyle() {
                    mb.mapstyle = {
                        natural: {
                            true:  "openstreetmap-openmaptiles/maputnik/liberty",
                            false: "naturalearth-openmaptiles/maputnik/liberty",
                        },
                        political:  {
                            true:  "openstreetmap-openmaptiles/openmaptiles/basic",
                            false: undefined, // We will hide this option for naturalearth since it's not great for political maps - TODO Extract a low res osm for political map.
                        },
                        hybrid:  {
                            true:  "openstreetmap-openmaptiles/maps.black/hybrid-2023",
                            false: "naturalearth-openmaptiles/maps.black/hybrid-2023", // we'll have a smaller satellite file with the same name in this case
                        },
                        satellite:  {
                            true:  "raster/s2maps/2023",
                            false: "raster/s2maps/2023", // we'll have a smaller satellite file with the same name in this case
                        },
                    }[mapStyleChoice][osmTiles]
                    console.log("setting to", mapStyleChoice, "i.e.", mb.mapstyle)

                    addControls() // The above will reset the map so we have to add search again. This also covers page load.
                }
                setStyle = _setStyle

                // HEAD request just to see if the osm pmtiles file is there
                var http = new XMLHttpRequest();
                http.open('HEAD', "openstreetmap-openmaptiles.pmtiles");
                http.onreadystatechange = function() {
                    if (this.readyState == this.DONE) {
                        // If we get a 200 it means the osm pmtiles file
                        // exists.
                        osmTiles = this.status === 200

                        // Set the mapstyle as soon as we know whether it
                        // should be osm. This will probably be the
                        // initial state of the dropdown, since this will
                        // probably finish before the user has a chance to
                        // change the dropdown.
                        setStyle()
                    }
                };
                http.send();

                class MapsDotBlackStyleControl {
                    onAdd(map) {
                        this._map = map;
                        this._container = document.createElement('div');
                        this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group';

                        const naturalSelected = mapStyleChoice === "natural" ? `selected="selected"` : ""
                        const politicalSelected = mapStyleChoice === "political" ? `selected="selected"` : ""
                        const satelliteSelected = mapStyleChoice === "satellite" ? `selected="selected"` : ""
                        const hybridSelected = mapStyleChoice === "hybrid" ? `selected="selected"` : ""

                        // For now don't include political for naturalearth because it doesn't have great political options zoomed out
                        const maybePolitical = osmTiles ? `<option value="political" ${politicalSelected}>&#x1F3F3;</option>` : "";

                        // Keep in mind that maps.black destroys and creates this every time we change the map style or features.
                        // This makes it a little complicated to add handlers. So for now, I inline it.
                        //
                        // appearance: none - get rid of the little arrow from the dropdown
                        // border: none - get rid of the standard select tag border
                        // outline: none - don't highlight it after using (noticed on Chromium)
                        // border-radius is done here, but border as such is done by maplibregl-ctrl-group
                        // height and width experimentally match the Globe control
                        // padding and font size are a balance:
                        // * Make icons big enough (I'd like to make them a little bigger)
                        // * Make icons nicely centered
                        // * Make room for the "+" I'm cramming into the Hybrid option
                        // * TODO - Just get some images for this part and make it consistent
                        this._container.innerHTML = `
                            <select
                              class="styleswitch"
                              id="styleswitch"
                              onchange="mapStyleChoice = this.value; setStyle()"
                              style="background: white; padding-top:2px; padding-left:5px; border: none; outline: none; appearance: none; font-size: 13px; border-radius: 5px; height: 29px; width: 29px;"
                            >
                                <option value="natural" ${naturalSelected}>&#x1F33F;</option>
                                ${maybePolitical}
                                <option value="satellite" ${satelliteSelected}>&#x1F4E1;</option>
                                <option value="hybrid" ${hybridSelected}>&#x1F4E1;+</option>
                            </select>
                        `
                        return this._container;
                    }

                    onRemove() {
                        this._container.parentNode.removeChild(this._container);
                        this._map = undefined;
                    }
                }

                class MapsDotBlackGlobeControl extends maplibregl.GlobeControl {
                    onAdd(map) {
                        // Depends on GlobeControl using `_toggleProjection` internally in this
                        // way, which might change in a different version of maplibregl:
                        // https://github.com/maplibre/maplibre-gl-js/blob/93634b011a147666a62887bc61bffd351fa9971d/src/ui/control/globe_control.ts
                        //
                        // The reason we are doing this is that maps.black has its own wrapper for
                        // projection, among other aspects of the map. Rather than directly accessing the
                        // underlying map object to change the projection (as maplibregl.GlobeControl
                        // does), we will overload this method to use maps.black's wrapper.
                        //
                        // TODO implement this in a less hacky way, maybe. like maybe from scratch?
                        this._toggleProjection = () => {
                            // Not ideal to use the global `mb` but the alternative would be contrived and probably more error prone
                            mb.globe = !mb.globe

                            // Changing "features" of mb such as globe, or "mapstyle", seems to cause maps.black to
                            //  rebuild the map, and inthe process dumping all of the controls we added. So, we have
                            // to add them again.
                            addControls()
                        }

                        return super.onAdd(map)
                    }
                }

                const mb = document.getElementsByTagName("maps-black")[0];

                // set the mapstyle on dropdown change

                // https://maplibre.org/maplibre-gl-js/docs/examples/geocode-with-nominatim/
                const nominatimGeocoderApi = {
                    // TODO reverse geocode
                    forwardGeocode: async (config) => {
                        const features = [];
                        try {
                            const request = `/nominatim/search?q=${
                                config.query
                            }&format=geojson&polygon_geojson=1&addressdetails=1&extratags=1`;
                            const response = await fetch(request);
                            const geojson = await response.json();
                            for (const feature of geojson.features) {
                                const center = [
                                    feature.bbox[0] + (feature.bbox[2] - feature.bbox[0]) / 2,
                                    feature.bbox[1] + (feature.bbox[3] - feature.bbox[1]) / 2,
                                ];
                                const point = {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Point',
                                        coordinates: center
                                    },
                                    place_name: feature.properties.display_name,
                                    properties: feature.properties,
                                    text: feature.properties.display_name,
                                    place_type: ['place'],
                                    extratags: feature.properties.extratags,
                                    center,

                                    // TODO When you click on a search result in the list, it sets the view around that *specific* result's *bbox* specified here.
                                    // On the other hand, hitting Enter in the search input sets the view around *all* of the result *markers* (with maximum zoom of 10).
                                    // Ideally, it would set the view around *all* of the result *bboxes*, I think. So let's figure that out.
                                    bbox: feature.bbox,
                                };
                                features.push(point);
                            }
                            // Just show borders for all results, for demo purposes for now.
                            // Cut off at 5 because that's the number of markers that get shown.
                            // TODO - have it only show the border when you actually click on a search result.
                            showSearchResultBorder(geojson.features.slice(0, 5))
                        } catch (e) {
                            console.error(`Failed to forwardGeocode with error: ${e}`);
                        }

                        return {
                            features
                        };
                    }
                };

                function showSearchResultBorder(searchResult) {
                    const source = mb.map.getSource('search-result')
                    if (source) {
                        // TODO - can we do source.updateData(searchResult) instead ???
                        mb.map.removeLayer('search-result-polygons')
                        mb.map.removeLayer('search-result-outline')
                        mb.map.removeSource('search-result')
                    }
                    mb.map.addSource('search-result', {
                      type: 'geojson',
                      data: {type: 'FeatureCollection', features: searchResult}
                    });
                    mb.map.addLayer({id: "search-result-polygons", type: "fill", source: 'search-result', layout:{}, paint: {'fill-color': '#FF4444', 'fill-opacity': 0.2}})
                    mb.map.addLayer({id: "search-result-outline", type: "line", source: 'search-result', layout:{}, paint: {'line-color': '#FF4444', 'line-width': 2}})
                }

                // have to use MAX_ZOOM in a couple different places to cover a couple different scenarios, it seems
                const MAX_ZOOM = 10;
                const geocoder = new MaplibreGeocoder(nominatimGeocoderApi, {
                    maplibregl,
                    zoom: MAX_ZOOM,
                    flyTo: {
                        maxZoom: MAX_ZOOM,
                    },
                    popup: true,
                })
                let addControlsTimeout = null
                function addControls() {
                    // Whether we're setting a new timeout or actually adding the search, make sure no further timeouts are looming.
                    clearTimeout(addControlsTimeout)
                    if (geocoder._map) {
                      // Neither add a map nor set a timer
                      return
                    }

                    // TODO use a maps-dot-black "on add map" callback instead, if such a thing exists.
                    // The problem is that at on creation, mb doesn't immediately contain a map.
                    if (mb.map && mb.map.style) { // NOTE mb.map.loaded() becomes true much later than mb.map.style. mb.map.style seems to be sufficient.
                        // sigh. deal with sneaking the style sheets into a "Shadow DOM" here. Thankfully this somehow isn't an issue with javascript.
                        // https://stackoverflow.com/questions/79736280/importing-a-css-stylesheet-into-a-webcomponent-with-shadow-dom-in-firefox/79744809#79744809
                        // TODO - See if I can do this in a more direct way. I only need the geocoder css as part of this shadow DOM. Also I probably don't need the
                        // other maplibre css, that's probably already included in maps.black.
                        const mapLibreGlCSS = [...document.styleSheets].find((styleSheet) => styleSheet.href.split('/').pop() === 'maplibre-gl-geocoder.css');
                        const stylesheetText = [...mapLibreGlCSS.cssRules].reduce((accumulator, rule) => accumulator + rule.cssText, '');
                        const myStyles = new CSSStyleSheet()
                        myStyles.replace(stylesheetText)
                        mb.shadowRoot.adoptedStyleSheets = [...mb.shadowRoot.adoptedStyleSheets, myStyles]

                        mb.map.addControl(geocoder, 'top-left');
                        mb.map.addControl(new maplibregl.ScaleControl());
                        mb.map.addControl(new MapsDotBlackGlobeControl(), 'top-right');
                        mb.map.addControl(new MapsDotBlackStyleControl(), 'top-right');
                        // NOTE Navigation control is added via `navigationcontrol` attribute on the maps-black tag
                    } else {
                        // For now try periodically until it's ready.
                        addControlsTimeout = setTimeout(addControls, 100)
                    }
                }
            });
        </script>
    </head>
    <body style="height:calc(100% - 10px); margin: 5px; padding: 0;">
        <maps-black style="height:100%" loader="pmtiles" navigationcontrol="true"></maps-black>
        <script src="maplibre-gl-geocoder.min.js"></script>
        <link
            rel="stylesheet"
            href="maplibre-gl-geocoder.css"
        />
    </body>
</html>
