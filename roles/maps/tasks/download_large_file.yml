# This will download large files using aria2c and meta4 files, and possibly
# torrent files.
#
# There are a few concerns for downloading such files which we may or may not be
# addressing at this time:
#
# Efficiency for implementers:
#
# * We will work toward supporting torrents, which may be faster than http.
# * aria2c will hopefully perform checksums in-memory (even if via disk cache)
#   during download. This will be faster than a full checksum after download,
#   which definitely requires disk read for large files.
# * Once files are fully downloaded and moved out of the temp directory, they
#   will not be downloaded on subsequent role runs. (This relates to "Updating
#   data" below)
#
# Integrity: aria2 will perform a sha256 checksum on each downloaded chunk of
# the file.
#
# Security: If there is a security concern down the line, we can provide PGP
# signatures for the meta4 and/or torrent files.
#
# Consistent versions: Data file versions may correspond to each other (e.g.
# vector map "extracts" should ideally match the low-res world map). This can
# be handled by putting a date in the file names of the data files. The date
# can be committed to the repository. However, at this time this concern is
# handled upstream of this file.
#
# Updating data: As of Dec 2025 this concern is out of scope. We assume that
# users will either figure it out on their own, or reinstall IIAB from scratch.
# That said, assuming we have dates in file names, this may be supported de
# facto, but we will not go out of our way to free up room by deleting the
# outdated files. (Perhaps adding automatic deletion will not be so hard once
# the time comes)
#
# TODO - files should be owned by www-data


- vars:
    # Where the file eventually goes
    dest_path: "{{ dest_base_path }}/{{ item }}"

    # Use md5sum to generate the log file name:
    # * Name has short, consistent length. The "to check progress..." message
    #   fits within 80 characters on terminal (at least in the current
    #   ansible version) in case users have small screens.
    # * If the user mis-copies, it's less likely to do anything destructive.
    log_file: "{{ item | hash('md5') }}.log"
    working_dir: "/library/downloads/maps"

  block:
    - name: "Fetching file size for {{ iiab_map_host_url }}/{{ item }} via .meta4 file"
      shell: |
        import sys, xmltodict, requests, os

        if os.path.exists("{{ dest_path }}"):
          sys.exit(0)

        size = int(xmltodict.parse(
          requests.get("{{ iiab_map_host_url }}/{{ item }}.meta4").content
        )['metalink']['file']['size'])
        KiB = 1024
        MiB = KiB * 1024
        GiB = MiB * 1024

        if size < MiB:
          size_disp = str(round(size / KiB, 2)) + ' KiB'
        elif size < GiB:
          size_disp = str(round(size / MiB, 2)) + ' MiB'
        else:
          size_disp = str(round(size / GiB, 2)) + ' GiB'
        print('(' + size_disp + ') To check download progress, see previous step (above).')
      args:
        executable: /usr/bin/python3

      # The existence of console output in download_file_details
      # implies that the download should happen.
      register: download_file_details

    # Put in some space to make it easier to read by implementers.
    - debug:
        msg:
          - ""
          - ""
          - "   To check download progress, run:       "
          - ""
          - "   tail {{ working_dir }}/{{ log_file }}  "
          - ""
          - ""
      # If the file already exists (and thus no download will happen) the above
      # task should exit before any console output.
      when: download_file_details.stdout_lines|length != 0

    - name: "Download {{ item }} {{ download_file_details.stdout_lines.0 | default('(done)')}}"
      # cd to the temp directory so that the aria2c file, data file, and (perhaps
      # eventually) torrent file all end up there.
      shell: |
        set -euo pipefail

        cd {{ working_dir }}

        date > "{{ log_file }}"
        echo "Downloading {{ item }}..." >> "{{ log_file }}"
        echo >> "{{ log_file }}"
        aria2c \
            --async-dns=false \
            --connect-timeout="{{ download_timeout }}" \
            --log-level=warn \
            --console-log-level=warn \
            --summary-interval=60 \
            --download-result=hide \
            --follow-metalink=mem \
            --max-connection-per-server=4 \
            --file-allocation=falloc \
            --show-console-readout=false \
            --enable-http-pipelining=true \
            --seed-time=0 \
            "{{ iiab_map_host_url }}/{{ item }}.meta4" \
            >> "{{ log_file }}"

        chmod 644 "{{ item }}"
        mv "{{ item }}" "{{ dest_path }}"
        rm "{{ log_file }}"
      args:
        executable: /bin/bash
        creates: "{{ dest_path }}"

  rescue:
    # We output summaries to a log file for the user's benefit,
    # but all of the errors necessarily show up there as well.
    # Here, we parse out the error message, ignoring almost all of
    # the summary lines, which could be a lot.
    # Finally, we exit 1 so Ansible shows this error.
    - name: "Error downloading {{ item }}"
      shell: |
        set -euo pipefail

        cd {{ working_dir }}

        echo "aria2c error:" 1>&2
        tac "{{ log_file }}" | sed '/'"Download Progress Summary as of"'/q' | tac 1>&2
        exit 1
