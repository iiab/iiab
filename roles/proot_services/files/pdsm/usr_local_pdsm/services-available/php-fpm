#!/bin/sh
# /usr/local/pdsm/services-available/php-fpm
# Simple PDSM service wrapper for php-fpm

PDSM_COMMON="/usr/local/pdsm/lib/pdsm-common.sh"
[ -r "$PDSM_COMMON" ] && . "$PDSM_COMMON"

SERVICE_NAME="php-fpm"

PHP_FPM_BIN="/usr/sbin/php-fpm${PHP_FPM_VERSION}"
PHP_FPM_CONF="/etc/php/${PHP_FPM_VERSION}/fpm/php-fpm.conf"
PHP_FPM_PIDFILE="/run/php/php${PHP_FPM_VERSION}-fpm.pid"

[ -f "$PHP_FPM_BIN" ] || echo "No binary for php-fph"

running() {
  # NOTE: use process id to identify service is running.
  [ -s "$PHP_FPM_PIDFILE" ] || return 1

  pid="$(cat "$PHP_FPM_PIDFILE" 2>/dev/null || echo '')"
  [ -n "$pid" ] || return 1

  kill -0 "$pid" 2>/dev/null
}

start() {
  if running; then
    echo "[pdsm:$SERVICE_NAME] already running"
    return 0
  fi

  echo "[pdsm:$SERVICE_NAME] starting..."

  mkdir -p /run/php

  "$PHP_FPM_BIN" --fpm-config "$PHP_FPM_CONF"

  # Small wait loop so 'start' only returns when it's actually alive
  for i in $(seq 1 "$PDSM_START_TIMEOUT"); do
    if running; then
      echo "[pdsm:$SERVICE_NAME] started"
      return 0
    fi
    sleep 1
  done

  echo "[pdsm:$SERVICE_NAME] failed to start" >&2
  return 1
}

stop() {
  if ! running; then
    echo "[pdsm:$SERVICE_NAME] already stopped"
    return 0
  fi

  echo "[pdsm:$SERVICE_NAME] stopping..."

  pid="$(cat "$PHP_FPM_PIDFILE" 2>/dev/null || echo '')"

  if [ -n "$pid" ]; then
    kill -QUIT "$pid" 2>/dev/null || kill "$pid" 2>/dev/null || true
  fi

  # Wait a little to ensure everything stopped
  for i in $(seq 1 "$PDSM_START_TIMEOUT"); do
    if ! running; then
      echo "[pdsm:$SERVICE_NAME] stopped"
      return 0
    fi
    sleep 1
  done

  echo "[pdsm:$SERVICE_NAME] did not fully stop" >&2
  return 1
}

status() {
  if running; then
    echo "[pdsm:$SERVICE_NAME] running"
    return 0
  fi
  echo "[pdsm:$SERVICE_NAME] not running"
  return 3
}

case "$1" in
  start|stop|status)
    "$1"
    ;;
  restart)
    stop
    start
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|status}" >&2
    exit 1
    ;;
esac
