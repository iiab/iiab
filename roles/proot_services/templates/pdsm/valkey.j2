#!/bin/sh
# /usr/local/pdsm/services-available/valkey
# PDSM service wrapper for Valkey (accepts Redis as fallback)

PDSM_COMMON="/usr/local/pdsm/lib/pdsm-common.sh"
[ -r "$PDSM_COMMON" ] && . "$PDSM_COMMON"

SERVICE_NAME="valkey"
PDSM_START_TIMEOUT=30

# Attempt to detect Valkey vs Redis
if command -v valkey-server >/dev/null 2>&1; then
    BIN="valkey-server"
    USER="valkey"
    CONF_FILE="/etc/valkey/valkey.conf"
    PIDFILE="/run/valkey/valkey-server.pid"
    LOGFILE="/var/log/valkey/valkey-server.log"
    DIR="/var/lib/valkey"
elif command -v redis-server >/dev/null 2>&1; then
    BIN="redis-server"
    USER="redis"
    CONF_FILE="/etc/redis/redis.conf"
    PIDFILE="/run/redis/redis-server.pid"
    LOGFILE="/var/log/redis/redis-server.log"
    DIR="/var/lib/redis"
else
    echo "[pdsm:$SERVICE_NAME] valkey-server or redis-server not found" >&2
    exit 1
fi

mkdir -p "$(dirname "$PIDFILE")"
mkdir -p "$(dirname "$LOGFILE")"
mkdir -p "$DIR"
# Ensure user owns directories AND existing logs to prevent startup crash
chown -R "$USER":"$USER" "$(dirname "$PIDFILE")" "$(dirname "$LOGFILE")" "$DIR" 2>/dev/null || true

running() {
    # 1. Check screen first (most reliable in PRoot)
    if screen -list | grep -q "\.$SERVICE_NAME"; then
        return 0
    fi
    # 2. Fallback to PID file
    [ -s "$PIDFILE" ] || return 1
    pid="$(cat "$PIDFILE" 2>/dev/null || echo '')"
    [ -n "$pid" ] || return 1
    kill -0 "$pid" 2>/dev/null || pgrep -u "$USER" -f "$BIN" >/dev/null
}

start() {
    if running; then
        echo "[pdsm:$SERVICE_NAME] already running ($BIN)"
        return 0
    fi

    echo "[pdsm:$SERVICE_NAME] starting $BIN..."
    # Proactively cleanup stale socket (Proot /tmp is persistent!)
    rm -f /tmp/valkey.sock

    # Build command
    CMD="$BIN"
    [ -f "$CONF_FILE" ] && CMD="$CMD $CONF_FILE"
    # FORCE foreground for screen, and ENABLE UNIX SOCKET for Android apps
    CMD="$CMD --daemonize no --pidfile $PIDFILE --logfile $LOGFILE --dir $DIR --unixsocket /tmp/valkey.sock --unixsocketperm 777"

    # Use screen for persistence
    if id -u "$USER" >/dev/null 2>&1; then
        screen -dmS "$SERVICE_NAME" su -s /bin/sh "$USER" -c "$CMD"
    else
        screen -dmS "$SERVICE_NAME" $CMD
    fi

    # Stabilization Verification Loop
    for i in $(seq 1 "$PDSM_START_TIMEOUT"); do
        # Sleep first to allow immediate crash to happen
        sleep 1
        if running; then
            # Verify process is truly stable (not just a zombie screen)
            if [ -S /tmp/valkey.sock ]; then
                 echo "[pdsm:$SERVICE_NAME] started (socket found)"
                 return 0
            fi
            # If no socket yet, wait longer or trust screen if it persists
             echo "[pdsm:$SERVICE_NAME] started"
             return 0
        else
            if ! screen -list | grep -q "\.$SERVICE_NAME"; then
                 echo "[pdsm:$SERVICE_NAME] failed (screen died)" >&2
                 return 1
            fi
        fi
    done

    echo "[pdsm:$SERVICE_NAME] failed to start (timeout)" >&2
    return 1
}

stop() {
    if ! running; then
        echo "[pdsm:$SERVICE_NAME] already stopped"
        return 0
    fi

    echo "[pdsm:$SERVICE_NAME] stopping..."
    
    pid="$(cat "$PIDFILE" 2>/dev/null)"
    if [ -n "$pid" ]; then
        kill "$pid" 2>/dev/null || true
        for i in $(seq 1 "$PDSM_START_TIMEOUT"); do
            if ! running; then
                break
            fi
            sleep 1
        done
        kill -9 "$pid" 2>/dev/null || true
        screen -X -S "$SERVICE_NAME" quit >/dev/null 2>&1 || true
        rm -f "$PIDFILE"
        rm -f /tmp/valkey.sock
    fi

    echo "[pdsm:$SERVICE_NAME] did not fully stop" >&2
    return 1
}

status() {
    if running; then
        echo "[pdsm:$SERVICE_NAME] running ($BIN)"
        return 0
    fi
    echo "[pdsm:$SERVICE_NAME] not running"
    return 3
}

case "$1" in
    start|stop|status) "$1" ;;
    restart) stop; start ;;
    *) echo "Usage: $0 {start|stop|restart|status}" >&2; exit 1 ;;
esac
