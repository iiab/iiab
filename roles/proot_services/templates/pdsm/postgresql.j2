#!/bin/sh
# /usr/local/pdsm/services-available/postgresql
# PDSM service wrapper for PostgreSQL
# Refactored to use screen for PRoot stability

PDSM_COMMON="/usr/local/pdsm/lib/pdsm-common.sh"
[ -r "$PDSM_COMMON" ] && . "$PDSM_COMMON"

SERVICE_NAME="postgresql"
PDSM_START_TIMEOUT=30

PG_VERSION="15" 
# Detect version (naive)
if [ -d "/usr/lib/postgresql/17/bin" ]; then
    PG_VERSION="17"
elif [ -d "/usr/lib/postgresql/16/bin" ]; then
    PG_VERSION="16"
elif [ -d "/usr/lib/postgresql/15/bin" ]; then
    PG_VERSION="15"
elif [ -d "/usr/lib/postgresql/13/bin" ]; then
    PG_VERSION="13"
fi

BIN_DIR="/usr/lib/postgresql/$PG_VERSION/bin"
POSTGRES_BIN="$BIN_DIR/postgres"
INITDB_BIN="$BIN_DIR/initdb"

PGDATA="/library/pgsql-iiab"
PIDFILE="$PGDATA/postmaster.pid"
LOGFILE="/var/log/postgresql/postgresql.log"

if [ ! -x "$POSTGRES_BIN" ]; then
    echo "[pdsm:$SERVICE_NAME] ERROR: postgres binary not found at $POSTGRES_BIN" >&2
    exit 1
fi

mkdir -p /var/log/postgresql
chown postgres:postgres /var/log/postgresql 2>/dev/null || true

# Helper to init db if strict
init_db_if_needed() {
    if [ ! -d "$PGDATA" ] || [ -z "$(ls -A "$PGDATA")" ]; then
        echo "[pdsm:$SERVICE_NAME] initializing database in $PGDATA..."
        mkdir -p "$PGDATA"
        chown postgres:postgres "$PGDATA"
        su - postgres -c "$INITDB_BIN -D $PGDATA" || return 1
    fi
    return 0
}

running() {
    # Check PID file existence and content
    if [ -f "$PIDFILE" ]; then
        PID=$(head -n 1 "$PIDFILE")
        # Check if process is alive
        if kill -0 "$PID" 2>/dev/null; then
            return 0
        fi
    fi
    # Fallback: Check for screen session
    if screen -list | grep -q "$SERVICE_NAME"; then
         return 0
    fi
    return 1
}

start() {
    if running; then
        echo "[pdsm:$SERVICE_NAME] already running"
        return 0
    fi

    echo "[pdsm:$SERVICE_NAME] starting..."
    
    # Proactively cleanup stale socket (Proot /tmp is persistent!)
    rm -f /tmp/.s.PGSQL.5432
    
    # Self-Healing: Check for stale PID lock
    if [ -f "$PIDFILE" ]; then
        PID=$(head -n 1 "$PIDFILE")
        if ! kill -0 "$PID" 2>/dev/null; then
             echo "[pdsm:$SERVICE_NAME] Removing stale PID file (PID $PID not running)"
             rm -f "$PIDFILE"
        fi
    fi

    init_db_if_needed || { echo "[pdsm:$SERVICE_NAME] initdb failed"; return 1; }

    # Ensure reliable listening on TCP and fix PID location for Proot
    if [ -f "$PGDATA/postgresql.conf" ]; then
        # Force TCP listening
        if ! grep -q "listen_addresses = '*'" "$PGDATA/postgresql.conf"; then
            echo "listen_addresses = '*'" >> "$PGDATA/postgresql.conf"
        fi
        if ! grep -q "port = 5432" "$PGDATA/postgresql.conf"; then
            echo "port = 5432" >> "$PGDATA/postgresql.conf"
        fi
        # Force socket in /tmp for Proot compatibility (fixes connection refused)
        if ! grep -q "unix_socket_directories = '/tmp'" "$PGDATA/postgresql.conf"; then
            echo "unix_socket_directories = '/tmp'" >> "$PGDATA/postgresql.conf"
        fi
        # Disable external_pid_file which puts pid in /run/postgresql (often invalid in Proot)
        # We rely on postmaster.pid in PGDATA
        sed -i "s/^external_pid_file/#external_pid_file/" "$PGDATA/postgresql.conf"
    fi

    # Start via screen for persistence
    # We run 'postgres' directly in foreground inside screen
    screen -dmS "$SERVICE_NAME" su - postgres -c "$POSTGRES_BIN -D $PGDATA >> $LOGFILE 2>&1"

    for i in $(seq 1 "$PDSM_START_TIMEOUT"); do
        if running; then
            echo "[pdsm:$SERVICE_NAME] started"
            return 0
        fi
        sleep 1
    done

    echo "[pdsm:$SERVICE_NAME] failed to start" >&2
    return 1
}

stop() {
    if ! running; then
        echo "[pdsm:$SERVICE_NAME] already stopped"
        return 0
    fi

    echo "[pdsm:$SERVICE_NAME] stopping..."
    
    # Try graceful stop via signal to PID
    if [ -f "$PIDFILE" ]; then
        PID=$(head -n 1 "$PIDFILE")
        kill -TERM "$PID" 2>/dev/null
    fi

    for i in $(seq 1 "$PDSM_START_TIMEOUT"); do
        if ! running; then
            echo "[pdsm:$SERVICE_NAME] stopped"
            return 0
        fi
        sleep 1
    done

    # Force kill screen if still running
    screen -X -S "$SERVICE_NAME" quit >/dev/null 2>&1 || true
    
    if ! running; then
        echo "[pdsm:$SERVICE_NAME] stopped (forced)"
        return 0
    fi

    echo "[pdsm:$SERVICE_NAME] did not fully stop" >&2
    return 1
}

status() {
    if running; then
        echo "[pdsm:$SERVICE_NAME] running"
        return 0
    fi
    echo "[pdsm:$SERVICE_NAME] not running"
    return 3
}

case "$1" in
    start|stop|status) "$1" ;;
    restart) stop; start ;;
    *) echo "Usage: $0 {start|stop|restart|status}" >&2; exit 1 ;;
esac
