#!/bin/sh
# /usr/local/pdsm/services-available/wuzapi
# PDSM service wrapper for Wuzapi
# Refactored for VM Parity and Proot stability

PDSM_COMMON="/usr/local/pdsm/lib/pdsm-common.sh"
[ -r "$PDSM_COMMON" ] && . "$PDSM_COMMON"

SERVICE_NAME="wuzapi"
PDSM_START_TIMEOUT=30

PIDFILE="/run/wuzapi.pid"
LOGFILE="/var/log/wuzapi/wuzapi.log"
BIN="/usr/local/bin/wuzapi"

# Default to 8095 if not set
: ${WUZAPI_PORT:=8095}
: ${WUZAPI_ADMIN_TOKEN:="{{ wuzapi_admintoken | default('Y1234567890abcdefghijkl098765', true) }}"}

mkdir -p "$(dirname "$PIDFILE")"
mkdir -p "$(dirname "$LOGFILE")"

running() {
  [ -s "$PIDFILE" ] || return 1
  pid="$(cat "$PIDFILE" 2>/dev/null || echo '')"
  [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null && return 0
  
  # Fallback: check if port is answering (handling Proot process visibility issues)
  curl -I "http://127.0.0.1:$WUZAPI_PORT" -s -m 1 | grep -q "HTTP"
}

start() {
  if running; then
    echo "[pdsm:$SERVICE_NAME] already running"
    return 0
  fi

  echo "[pdsm:$SERVICE_NAME] starting..."
  export USER=iiab-admin
  # Symlink logic handles location, but ensure we use the BIN path
  if [ ! -x "$BIN" ]; then
      echo "[pdsm:$SERVICE_NAME] Binary $BIN not found or not executable" >&2
      # Fallback or error? Error preferred.
      return 1
  fi
  
  # Proactive cleanup: kill anything holding the port to prevent bind errors
  # This is critical in Proot/Android where sockets linger
  fuser -k "$WUZAPI_PORT/tcp" >/dev/null 2>&1 || true

  # Ensure PIDFILE directory is writable by the user
  touch "$PIDFILE"
  chown $USER "$PIDFILE"

  # Screen for persistence with atomic PID write attempt
  screen -dmS "$SERVICE_NAME" su -s /bin/bash "$USER" -c "\
    echo \$\$ > \"$PIDFILE\"; \
    cd \"$WUZAPI_DIR\" || exit 1; \
    exec $BIN \
      -port $WUZAPI_PORT \
      -admintoken \"$WUZAPI_ADMIN_TOKEN\" \
      -logtype json \
      -wadebug False \
      >>\"$LOGFILE\" 2>&1"

  # Wait for PID file to contain something
  for i in $(seq 1 5); do
      [ -s "$PIDFILE" ] && break
      sleep 1
  done

  for i in $(seq 1 "$PDSM_START_TIMEOUT"); do
    if running; then
      echo "[pdsm:$SERVICE_NAME] started"
      return 0
    fi
    sleep 1
  done

  echo "[pdsm:$SERVICE_NAME] failed to start" >&2
  return 1
}

stop() {
  if ! running; then
    echo "[pdsm:$SERVICE_NAME] already stopped"
    return 0
  fi

  echo "[pdsm:$SERVICE_NAME] stopping..."
  
  pid="$(cat "$PIDFILE" 2>/dev/null)"
  if [ -n "$pid" ]; then
    kill "$pid" 2>/dev/null || true
    sleep 2
    if running; then
       kill -9 "$pid" 2>/dev/null || true
    fi
    screen -X -S "$SERVICE_NAME" quit >/dev/null 2>&1 || true
    rm -f "$PIDFILE"
  fi
  
  echo "[pdsm:$SERVICE_NAME] stopped"
  return 0
}

status() {
  if running; then
    echo "[pdsm:$SERVICE_NAME] running"
    return 0
  fi
  echo "[pdsm:$SERVICE_NAME] not running"
  return 3
}

case "$1" in
  start|stop|status) "$1" ;;
  restart) stop; start ;;
  *) echo "Usage: $0 {start|stop|restart|status}" >&2; exit 1 ;;
esac
